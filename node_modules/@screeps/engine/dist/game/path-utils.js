"use strict";

//
// Simple open-closed list

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

exports.OpenClosed = function () {
    function OpenClosed(size) {
        _classCallCheck(this, OpenClosed);

        this.list = new Uint8Array(size);
        this.marker = 1;
    }

    _createClass(OpenClosed, [{
        key: "clear",
        value: function clear() {
            if (this.marker >= 253) {
                this.list = new Uint8Array(this.list.length);
                this.marker = 1;
            } else {
                this.marker += 2;
            }
        }
    }, {
        key: "isOpen",
        value: function isOpen(index) {
            return this.list[index] === this.marker;
        }
    }, {
        key: "isClosed",
        value: function isClosed(index) {
            return this.list[index] === this.marker + 1;
        }
    }, {
        key: "open",
        value: function open(index) {
            this.list[index] = this.marker;
        }
    }, {
        key: "close",
        value: function close(index) {
            this.list[index] = this.marker + 1;
        }
    }]);

    return OpenClosed;
}();

//
// Priority queue implementation w/ support for updating priorities
exports.Heap = function () {
    function Heap(size, ctor) {
        _classCallCheck(this, Heap);

        this.priorities = new (ctor || Uint16Array)(size + 1);
        this.heap = new Uint16Array(size + 1);
        this.size_ = 0;
    }

    _createClass(Heap, [{
        key: "minPriority",
        value: function minPriority() {
            return this.priorities[this.heap[1]];
        }
    }, {
        key: "min",
        value: function min() {
            return this.heap[1];
        }
    }, {
        key: "size",
        value: function size() {
            return this.size_;
        }
    }, {
        key: "priority",
        value: function priority(index) {
            return this.priorities[index];
        }
    }, {
        key: "pop",
        value: function pop() {
            this.heap[1] = this.heap[this.size_];
            --this.size_;
            var vv = 1;
            do {
                var uu = vv;
                if ((uu << 1) + 1 <= this.size_) {
                    if (this.priorities[this.heap[uu]] >= this.priorities[this.heap[uu << 1]]) {
                        vv = uu << 1;
                    }
                    if (this.priorities[this.heap[vv]] >= this.priorities[this.heap[(uu << 1) + 1]]) {
                        vv = (uu << 1) + 1;
                    }
                } else if (uu << 1 <= this.size_) {
                    if (this.priorities[this.heap[uu]] >= this.priorities[this.heap[uu << 1]]) {
                        vv = uu << 1;
                    }
                }
                if (uu !== vv) {
                    var tmp = this.heap[uu];
                    this.heap[uu] = this.heap[vv];
                    this.heap[vv] = tmp;
                } else {
                    return;
                }
            } while (true);
        }
    }, {
        key: "push",
        value: function push(index, priority) {
            this.priorities[index] = priority;
            var ii = ++this.size_;
            this.heap[ii] = index;
            this.bubbleUp(ii);
        }
    }, {
        key: "update",
        value: function update(index, priority) {
            for (var ii = this.size_; ii > 0; --ii) {
                if (this.heap[ii] === index) {
                    this.priorities[index] = priority;
                    this.bubbleUp(ii);
                    return;
                }
            }
        }
    }, {
        key: "bubbleUp",
        value: function bubbleUp(ii) {
            while (ii !== 1) {
                if (this.priorities[this.heap[ii]] <= this.priorities[this.heap[ii >>> 1]]) {
                    var tmp = this.heap[ii];
                    this.heap[ii] = this.heap[ii >>> 1];
                    this.heap[ii = ii >>> 1] = tmp;
                } else {
                    return;
                }
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            this.size_ = 0;
        }
    }]);

    return Heap;
}();
//# sourceMappingURL=../sourcemaps/game/path-utils.js.map
