#!/usr/bin/env node
'use strict';

var q = require('q'),
    _ = require('lodash'),
    utils = require('./utils'),
    driver = utils.getDriver(),
    config = require('./config');

var lastAccessibleRoomsUpdate = 0;
var usersLegacyQueue, roomsQueue, usersIvmQueue;

function loop() {

    var resetInterval,
        startLoopTime = process.hrtime ? process.hrtime() : Date.now(),
        stage = 'start';

    driver.config.emit('mainLoopStage', stage);

    if (typeof self == 'undefined') {
        resetInterval = setInterval(function () {
            console.error('Main loop reset! Stage:', stage);
            driver.queue.resetAll();
        }, driver.config.mainLoopResetInterval);
    }

    driver.notifyTickStarted().then(function () {
        stage = 'getUsers';
        driver.config.emit('mainLoopStage', stage);
        return driver.getAllUsers();
    }).then(function (users) {
        stage = 'addUsersToQueue';
        driver.config.emit('mainLoopStage', stage, users);
        return q.all([usersLegacyQueue.addMulti(users.legacy.map(function (user) {
            return user._id.toString();
        })), usersIvmQueue.addMulti(users.ivm.map(function (user) {
            return user._id.toString();
        }))]);
    }).then(function () {
        stage = 'waitForUsers';
        driver.config.emit('mainLoopStage', stage);
        return q.all([usersLegacyQueue.whenAllDone().then(function () {
            return driver.config.emit('mainLoopStage', stage, 'legacyDone');
        }), usersIvmQueue.whenAllDone().then(function () {
            return driver.config.emit('mainLoopStage', stage, 'ivmDone');
        })]);
    }).then(function () {
        stage = 'getRooms';
        driver.config.emit('mainLoopStage', stage);
        return driver.getAllRooms();
    }).then(function (rooms) {
        stage = 'addRoomsToQueue';
        driver.config.emit('mainLoopStage', stage, rooms);
        return roomsQueue.addMulti(_.map(rooms, function (room) {
            return room._id.toString();
        }));
    }).then(function () {
        stage = 'waitForRooms';
        driver.config.emit('mainLoopStage', stage);
        return roomsQueue.whenAllDone();
    }).then(function () {
        stage = 'commit1';
        driver.config.emit('mainLoopStage', stage);
        return driver.commitDbBulk();
    }).then(function () {
        stage = 'global';
        driver.config.emit('mainLoopStage', stage);
        return require('./processor/global')();
    }).then(function () {
        stage = 'commit2';
        driver.config.emit('mainLoopStage', stage);
        return driver.commitDbBulk();
    }).then(function () {
        stage = 'incrementGameTime';
        driver.config.emit('mainLoopStage', stage);
        return driver.incrementGameTime();
    }).then(function (gameTime) {
        console.log('Game time set to', gameTime);
        if (+gameTime > lastAccessibleRoomsUpdate + 20) {
            driver.updateAccessibleRoomsList();
            lastAccessibleRoomsUpdate = +gameTime;
        }

        stage = 'notifyRoomsDone';
        driver.config.emit('mainLoopStage', stage);
        return driver.notifyRoomsDone(gameTime);
    }).then(function () {
        stage = 'custom';
        driver.config.emit('mainLoopStage', stage);
        return driver.config.mainLoopCustomStage();
    }).catch(function (error) {
        if (error == 'Simulation paused') {
            return;
        }
        console.error('Error while main loop (stage ' + stage + '):', _.isObject(error) && error.stack ? error.stack : error);
    }).finally(function () {

        if (resetInterval) {
            clearInterval(resetInterval);
        }

        var usedTime;
        if (process.hrtime) {
            usedTime = process.hrtime(startLoopTime);
            usedTime = usedTime[0] * 1e3 + usedTime[1] / 1e6;
        } else {
            usedTime = Date.now() - startLoopTime;
        }

        driver.config.emit('mainLoopStage', 'finish');

        setTimeout(loop, Math.max(driver.config.mainLoopMinDuration - usedTime, 0));
    }).catch(function (error) {
        console.error('\'Error while main loop (final):', _.isObject(error) && error.stack ? error.stack : error);
    });
}

driver.connect('main').then(function () {
    return q.all([driver.queue.create('usersLegacy', 'write'), driver.queue.create('rooms', 'write'), driver.queue.create('usersIvm', 'write')]);
}).then(function (data) {
    usersLegacyQueue = data[0];
    roomsQueue = data[1];
    usersIvmQueue = data[2];
    loop();
}).catch(function (error) {
    return console.log('Error connecting to driver:', error);
});

if (typeof self == 'undefined') {
    setInterval(function () {
        var rejections = q.getUnhandledReasons();
        rejections.forEach(function (i) {
            return console.error('Unhandled rejection:', i);
        });
        q.resetUnhandledRejections();
    }, 1000);
}
//# sourceMappingURL=sourcemaps/main.js.map
